# App Maker 项目架构与设计文档

> 本文档为 Claude AI 助手准备，用于快速理解项目架构、设计思路和开发规范，确保在新会话中保持一致的架构和方案。

## 📋 项目概述

**App Maker** 是一个基于多 Agent 协作的自动化软件开发平台，通过 AI Agent 的协同工作，根据用户需求自动生成完整的前后端项目。

### 核心理念
- **想法即应用**: 用户只需描述需求，系统自动生成完整项目
- **多 Agent 协作**: PM、UX、Architect、PO、Dev 等专业角色协同工作
- **标准化流程**: 预定义的开发阶段流程，确保项目质量
- **容器化部署**: 生成的项目可直接容器化部署

### 技术栈总览
- **Frontend**: Vue 3 + TypeScript + Naive UI + Pinia
- **Backend**: Go + Gin + GORM + PostgreSQL + Asynq + Redis
- **Agents**: Go + Gin + Asynq + Redis
- **Shared-models**: Go 模块，提供共享数据模型和客户端
- **部署**: Docker + GitLab CI/CD + Traefik

---

## 🏗️ 系统架构

### 三层架构设计

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Frontend      │    │   Backend       │    │   Agents        │
│  (Vue.js 3)     │◄──►│   (Go + Gin)    │◄──►│  (Go + Gin)     │
│                 │    │                 │    │                 │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Nginx         │    │  PostgreSQL     │    │   BMad CLI      │
│   (反向代理)     │    │  Redis          │    │   Claude Code   │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 核心组件关系

1. **Frontend → Backend**
   - HTTP REST API 调用
   - WebSocket 实时通信
   - JWT Token 认证

2. **Backend → Agents**
   - 通过 `shared-models/client.AgentClient` 调用
   - 异步任务队列 (Asynq)
   - 任务状态轮询

3. **Agents → External Tools**
   - BMad CLI (支持 Claude Code, Qwen Code, Gemini 三种 CLI)
   - Git 版本控制
   - NPM/Node.js 环境

---

## 🗂️ 项目结构

```
app-maker/
├── frontend/                 # Vue.js 前端应用
│   ├── src/
│   │   ├── components/      # 组件 (layout, common, business)
│   │   ├── pages/          # 页面 (Home, Auth, Dashboard, ProjectEdit)
│   │   ├── stores/         # Pinia 状态管理 (user, project, file)
│   │   ├── router/         # 路由配置
│   │   ├── utils/          # 工具函数 (http, config, log, time)
│   │   └── types/          # TypeScript 类型定义
│   └── architect/          # 前端架构文档
│
├── backend/                 # Go 后端服务
│   ├── cmd/server/         # 服务入口
│   ├── internal/
│   │   ├── api/            # API 处理器 (handlers, middleware, routes)
│   │   ├── services/       # 业务逻辑 (project, user, websocket, file)
│   │   ├── models/         # 数据模型 (user, project, conversation, stage)
│   │   ├── repositories/   # 数据访问层
│   │   ├── config/         # 配置管理
│   │   ├── container/      # 依赖注入容器
│   │   └── worker/         # Asynq 异步任务处理
│   ├── pkg/cache/          # Redis 缓存管理
│   └── architect/          # 后端架构文档
│
├── agents/                  # Agents 服务
│   ├── cmd/server/         # 服务入口
│   ├── internal/
│   │   ├── api/            # API 处理器 (pm, ux, architect, po, dev)
│   │   ├── services/       # Agent 核心服务
│   │   │   ├── agent_task_service.go  # 任务队列管理
│   │   │   ├── command_service.go     # 命令执行
│   │   │   ├── git_service.go         # Git 操作
│   │   │   └── project_service.go     # 项目管理
│   │   ├── config/         # 配置管理
│   │   └── container/      # 依赖注入容器
│   └── design/             # Agents 架构文档
│
├── shared-models/          # 共享模块 (Go)
│   ├── agent/              # Agent 请求响应模型
│   │   ├── requests.go     # 请求结构体 (SetupProjEnvReq, GetPRDReq 等)
│   │   ├── response.go     # 响应结构体
│   │   └── roles.go        # Agent 角色定义
│   ├── client/             # HTTP 客户端
│   │   ├── agent_client.go # Agent 服务客户端
│   │   └── http_client.go  # HTTP 客户端封装
│   ├── common/             # 通用常量和响应
│   │   ├── constants.go    # 开发阶段、Agent 类型等常量
│   │   └── response.go     # 统一响应结构
│   ├── tasks/              # 异步任务模型
│   ├── utils/              # 工具函数 (file, password, time, uuid, zip)
│   └── logger/             # 日志管理
│
└── docs/                   # 项目文档
    ├── architect/          # 架构设计文档
    ├── design/             # 设计规范
    ├── PRD/                # 产品需求文档
    └── stories/            # Epic 和 Story 文档
```

---

## 👥 Agent 角色与协作流程

### Agent 角色定义

| Agent | 中文名 | 英文名 | 职责 |
|-------|--------|--------|------|
| Analyst | 需求分析师 | Mary | 分析项目需求，生成项目简介和市场研究 |
| PM | 产品经理 | John | 编写产品需求文档(PRD) |
| UX Expert | UX专家 | Sally | 设计用户体验标准和界面规范 |
| Architect | 架构师 | Winston | 设计系统、前端、后端技术架构，输出API、数据库设计文档 |
| PO | 产品负责人 | Sarah | 划分Epic和用户故事，任务分解和优先级管理 |
| Dev | 开发工程师 | James | 实现用户故事、修复Bug、测试、部署 |

### 开发阶段流程

```
用户需求输入 
  ↓
初始化 (initializing)
  ↓
环境准备 (setup_environment) → 项目 Clone、依赖安装
  ↓
等待Agents (pending_agents)
  ↓
需求检查 (check_requirement) → Analyst Agent
  ↓
生成PRD (generate_prd) → PM Agent
  ↓
定义UX标准 (define_ux_standard) → UX Expert Agent
  ↓
设计架构 (design_architecture) → Architect Agent
  ↓
划分Epic/Story (plan_epic_and_story) → PO Agent
  ↓
定义数据模型 (define_data_model) → Architect Agent
  ↓
定义API接口 (define_api) → Architect Agent
  ↓
开发Story (develop_story) → Dev Agent
  ↓
修复Bug (fix_bug) → Dev Agent (可选)
  ↓
运行测试 (run_test) → Dev Agent
  ↓
部署 (deploy) → Dev Agent
  ↓
完成 (done)
```

### 阶段常量定义

**位置**: `shared-models/common/constants.go`

```go
const (
    DevStatusInitializing       = "initializing"        // 等待开始
    DevStatusSetupEnvironment   = "setup_environment"   // 环境处理
    DevStatusPendingAgents      = "pending_agents"      // 等待Agents处理
    DevStatusCheckRequirement   = "check_requirement"   // 需求检查
    DevStatusGeneratePRD        = "generate_prd"        // 生成PRD
    DevStatusDefineUXStandard   = "define_ux_standard"  // UX标准定义
    DevStatusDesignArchitecture = "design_architecture" // 架构设计
    DevStatusPlanEpicAndStory   = "plan_epic_and_story" // Epic/Story划分
    DevStatusDefineDataModel    = "define_data_model"   // 数据模型定义
    DevStatusDefineAPI          = "define_api"          // API接口定义
    DevStatusDevelopStory       = "develop_story"       // Story开发
    DevStatusFixBug             = "fix_bug"             // Bug修复
    DevStatusRunTest            = "run_test"            // 自动测试
    DevStatusDeploy             = "deploy"              // 部署
    DevStatusDone               = "done"                // 完成
    DevStatusFailed             = "failed"              // 失败
)
```

---

## 🔄 数据流与调用关系

### 1. 项目创建流程

```
Frontend (CreateProject.vue)
  ↓ POST /api/v1/projects
Backend (ProjectHandler.Create)
  ↓ CreateProject()
ProjectService
  ↓ Create in DB
  ↓ Enqueue Task (Asynq)
Worker (project.go)
  ↓ ProcessTask()
ProjectStageService
  ↓ handleProjectDevelopmentTask()
  ↓ AgentClient.SetupProjectEnvironment()
Agents Service (/api/v1/project/setup)
  ↓ Clone Repo, Install Dependencies
  ↓ Git Commit & Push
Backend
  ↓ Update Project Status
  ↓ WebSocket Notify
Frontend
  ↓ Display Progress
```

### 2. Agent 任务执行流程

**Backend 调用 Agents**:
```go
// backend/internal/services/project_stage_service.go
agentClient := client.NewAgentClient(s.agentsURL, 10*time.Second)

// 调用 PM Agent 生成 PRD
result, err := agentClient.GetPRD(ctx, &agent.GetPRDReq{
    ProjectGuid:  project.GUID,
    Requirements: project.Requirements,
})
```

**Agents 处理任务**:
```go
// agents/internal/api/handlers/pm_handler.go
func (h *PmHandler) GetPRD(c *gin.Context) {
    var req agent.GetPRDReq
    c.ShouldBindJSON(&req)
    
    // 创建异步任务
    taskID := uuid.NewString()
    h.agentTaskService.Enqueue(req.ProjectGuid, "pm", "prd", req.ToBytes())
    
    c.JSON(200, utils.GetSuccessResponse("PRD任务已提交", taskID))
}
```

**Agents Worker 执行**:
```go
// agents/internal/services/agent_task_service.go
func (s *agentTaskService) ProcessTask(ctx context.Context, task *asynq.Task) error {
    // 执行 BMad CLI 命令
    result := s.commandService.SimpleExecute(ctx, workDir, "bmad", "run", "--prompt", promptFile)
    
    // Git 提交
    s.gitService.CommitAndPush(ctx, projectGuid, "Generated PRD document")
    
    return nil
}
```

### 3. WebSocket 实时通信

**Backend 推送消息**:
```go
// backend/internal/services/websocket_service.go
func (s *webSocketService) NotifyProjectStageUpdate(ctx context.Context, projectGuid string, stage *models.DevStage) {
    message := models.WebSocketMessage{
        Type: common.WebSocketMessageTypeProjectStageUpdate,
        Data: stage,
    }
    s.broadcastToProject(projectGuid, message)
}
```

**Frontend 接收消息**:
```typescript
// frontend/src/utils/websocket.ts
ws.onmessage = (event) => {
  const message = JSON.parse(event.data)
  
  if (message.type === 'project_stage_update') {
    // 更新项目阶段状态
    projectStore.updateStage(message.data)
  }
}
```

---

## 📦 Shared-Models 核心功能

### 1. Agent 请求模型

**位置**: `shared-models/agent/requests.go`

```go
// 项目环境准备
type SetupProjEnvReq struct {
    ProjectGuid     string `json:"project_guid"`
    GitlabRepoUrl   string `json:"gitlab_repo_url"`
    SetupBmadMethod bool   `json:"setup_bmad_method"`
    BmadCliType     string `json:"bmad_cli_type"`
    AiModel         string `json:"ai_model"`
    ModelProvider   string `json:"model_provider"`
    ApiToken        string `json:"api_token"`
}

// PRD 生成
type GetPRDReq struct {
    ProjectGuid  string `json:"project_guid"`
    Requirements string `json:"requirements"`
    CliTool      string `json:"cli_tool"` // 支持的 CLI 类型
}

// Epic/Story 划分
type GetEpicsAndStoriesReq struct {
    ProjectGuid string `json:"project_guid"`
    PrdPath     string `json:"prd_path"`
    ArchFolder  string `json:"arch_folder"`
    CliTool     string `json:"cli_tool"` // 支持的 CLI 类型
}

// Story 实现
type ImplementStoryReq struct {
    ProjectGuid string `json:"project_guid"`
    PrdPath     string `json:"prd_path"`
    ArchFolder  string `json:"arch_folder"`
    DbFolder    string `json:"db_folder"`
    ApiFolder   string `json:"api_folder"`
    UxSpecPath  string `json:"ux_spec_path"`
    EpicFile    string `json:"epic_file"`
    StoryFile   string `json:"story_file"`
    CliTool     string `json:"cli_tool"` // 支持的 CLI 类型
}
```

### 2. Agent 客户端

**位置**: `shared-models/client/agent_client.go`

```go
type AgentClient struct {
    httpClient *HTTPClient
}

// 核心方法
func (c *AgentClient) SetupProjectEnvironment(ctx context.Context, req *agent.SetupProjEnvReq) (*tasks.TaskResult, error)
func (c *AgentClient) AnalyseProjectBrief(ctx context.Context, req *agent.GetProjBriefReq) (*tasks.TaskResult, error)
func (c *AgentClient) GetPRD(ctx context.Context, req *agent.GetPRDReq) (*tasks.TaskResult, error)
func (c *AgentClient) GetUXStandard(ctx context.Context, req *agent.GetUXStandardReq) (*tasks.TaskResult, error)
func (c *AgentClient) GetArchitecture(ctx context.Context, req *agent.GetArchitectureReq) (*tasks.TaskResult, error)
func (c *AgentClient) GetEpicsAndStories(ctx context.Context, req *agent.GetEpicsAndStoriesReq) (*tasks.TaskResult, error)
func (c *AgentClient) ImplementStory(ctx context.Context, req *agent.ImplementStoryReq) (*tasks.TaskResult, error)
func (c *AgentClient) FixBug(ctx context.Context, req *agent.FixBugReq) (*tasks.TaskResult, error)
```

### 3. 通用常量

**位置**: `shared-models/common/constants.go`

```go
// Agent 类型常量
const (
    AgentTypeAnalyse    = "analyst"
    AgentTypePM         = "pm"
    AgentTypeUX         = "ux-expert"
    AgentTypeArchitect  = "architect"
    AgentTypePO         = "po"
    AgentTypeDev        = "dev"
)

// CLI 工具类型常量
const (
    CliToolClaudeCode = "claude-code"
    CliToolQwenCode   = "qwen-code"
    CliToolGemini     = "gemini"
)

// 任务类型常量
const (
    TaskTypeProjectDevelopment = "project:development"
    TaskTypeProjectDeploy      = "project:deploy"
    TaskTypeAgentExecute       = "agent:execute"
)

// WebSocket 消息类型
const (
    WebSocketMessageTypeProjectStageUpdate = "project_stage_update"
    WebSocketMessageTypeProjectMessage     = "project_message"
    WebSocketMessageTypeProjectInfoUpdate  = "project_info_update"
)
```

---

## 💾 数据模型设计

### 核心表结构

**1. Users (用户表)**
```sql
CREATE TABLE users (
    id UUID PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    username VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    name VARCHAR(100),
    avatar_url VARCHAR(500),
    role VARCHAR(50) DEFAULT 'user',
    status VARCHAR(20) DEFAULT 'active',
    created_at TIMESTAMP,
    updated_at TIMESTAMP
);
```

**2. Projects (项目表)**
```sql
CREATE TABLE projects (
    id UUID PRIMARY KEY,
    guid VARCHAR(100) UNIQUE NOT NULL,
    name VARCHAR(200) NOT NULL,
    description TEXT,
    requirements TEXT,
    user_id UUID REFERENCES users(id),
    status VARCHAR(50) DEFAULT 'draft',
    dev_status VARCHAR(50) DEFAULT 'initializing',
    dev_progress INTEGER DEFAULT 0,
    project_path VARCHAR(500),
    gitlab_repo_url VARCHAR(500),
    backend_port INTEGER,
    frontend_port INTEGER,
    current_task_id VARCHAR(100),
    bmad_cli_type VARCHAR(50),
    ai_model VARCHAR(100),
    model_provider VARCHAR(50),
    created_at TIMESTAMP,
    updated_at TIMESTAMP
);
```

**3. Dev_Stages (开发阶段表)**
```sql
CREATE TABLE dev_stages (
    id UUID PRIMARY KEY,
    project_id UUID REFERENCES projects(id),
    project_guid VARCHAR(100),
    name VARCHAR(100) NOT NULL,
    status VARCHAR(50) DEFAULT 'pending',
    progress INTEGER DEFAULT 0,
    log_data TEXT,
    task_id VARCHAR(100),
    created_at TIMESTAMP,
    updated_at TIMESTAMP
);
```

**4. Conversation_Messages (对话消息表)**
```sql
CREATE TABLE conversation_messages (
    id UUID PRIMARY KEY,
    project_guid VARCHAR(100),
    type VARCHAR(20) NOT NULL,
    agent_role VARCHAR(50),
    agent_name VARCHAR(100),
    content TEXT NOT NULL,
    markdown_content TEXT,
    is_markdown BOOLEAN DEFAULT FALSE,
    is_expanded BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP
);
```

---

## 🎨 Frontend 架构设计

### 组件层次结构

```
App.vue
  ├── PageLayout (布局组件)
  │   ├── Header (顶部导航)
  │   ├── Sidebar (侧边栏)
  │   └── RouterView (页面内容)
  │
  ├── Home (首页)
  │   └── SmartInput (智能输入框)
  │
  ├── Auth (认证页)
  │
  ├── Dashboard (仪表板)
  │
  └── ProjectEdit (项目编辑)
      ├── ConversationContainer (对话容器)
      │   ├── ConversationMessage (对话消息)
      │   └── DevStages (开发阶段)
      │
      └── ProjectPanel (项目面板)
          ├── FileTreeNode (文件树)
          └── MonacoEditor (代码编辑器)
```

### 状态管理 (Pinia Stores)

**1. User Store** (`frontend/src/stores/user.ts`)
```typescript
export const useUserStore = defineStore('user', () => {
  const user = ref<User | null>(null)
  const token = ref<string>('')
  const isAuthenticated = computed(() => !!token.value)
  
  function login(credentials: LoginCredentials) { /* ... */ }
  function logout() { /* ... */ }
  function updateProfile(profile: UserProfile) { /* ... */ }
  
  return { user, token, isAuthenticated, login, logout, updateProfile }
})
```

**2. Project Store** (`frontend/src/stores/project.ts`)
```typescript
export const useProjectStore = defineStore('project', () => {
  const projects = ref<Project[]>([])
  const currentProject = ref<Project | null>(null)
  
  async function fetchProjects(params?: ProjectListRequest) { /* ... */ }
  async function createProject(data: CreateProjectData) { /* ... */ }
  async function getProject(id: string) { /* ... */ }
  async function deleteProject(id: string) { /* ... */ }
  async function getProjectMessages(projectGuid: string) { /* ... */ }
  async function getProjectStages(projectGuid: string) { /* ... */ }
  
  return { 
    projects, currentProject, 
    fetchProjects, createProject, getProject, deleteProject,
    getProjectMessages, getProjectStages
  }
})
```

### HTTP 服务封装

**位置**: `frontend/src/utils/http.ts`

```typescript
class HttpService {
  private instance: AxiosInstance
  
  constructor() {
    this.instance = axios.create({
      baseURL: import.meta.env.VITE_API_BASE_URL,
      timeout: 10000
    })
    this.setupInterceptors()
  }
  
  private setupInterceptors() {
    // 请求拦截器 - 添加 Token
    this.instance.interceptors.request.use(config => {
      const token = localStorage.getItem('token')
      if (token) {
        config.headers.Authorization = `Bearer ${token}`
      }
      return config
    })
    
    // 响应拦截器 - 处理错误和 Token 刷新
    this.instance.interceptors.response.use(
      response => response.data,
      error => {
        if (error.response?.status === 401) {
          // 自动刷新 Token 或跳转登录
          this.handleUnauthorized()
        }
        return Promise.reject(error)
      }
    )
  }
}
```

---

## 🔧 Backend 核心服务

### 服务层架构

**1. Project Service** (`backend/internal/services/project_service.go`)
```go
type ProjectService interface {
    Create(ctx context.Context, req *models.CreateProjectRequest, userID string) (*models.Project, error)
    GetByID(ctx context.Context, id string, userID string) (*models.Project, error)
    List(ctx context.Context, req *models.ProjectListRequest, userID string) ([]*models.Project, int64, error)
    Delete(ctx context.Context, id string, userID string) error
    Update(ctx context.Context, id string, req *models.UpdateProjectRequest, userID string) (*models.Project, error)
}
```

**2. Project Stage Service** (`backend/internal/services/project_stage_service.go`)
```go
type ProjectStageService interface {
    GetProjectStages(ctx context.Context, projectGuid string) ([]*models.DevStage, error)
    ProcessTask(ctx context.Context, task *asynq.Task) error
}

// 核心执行逻辑
func (s *projectStageService) handleProjectDevelopmentTask(ctx context.Context, task *asynq.Task) error {
    // 解析任务
    var payload tasks.ProjectTaskPayload
    json.Unmarshal(task.Payload(), &payload)
    
    // 获取项目
    project := s.projectRepo.GetByGUID(ctx, payload.ProjectGuid)
    
    // 创建 Agent 客户端
    agentClient := client.NewAgentClient(s.agentsURL, 10*time.Second)
    
    // 按顺序执行开发阶段
    stages := []struct{
        status      common.DevStatus
        executor    func(...) error
    }{
        {DevStatusPendingAgents, s.pendingAgents},
        {DevStatusCheckRequirement, s.checkRequirement},
        {DevStatusGeneratePRD, s.generatePRD},
        {DevStatusDefineUXStandard, s.defineUXStandards},
        {DevStatusDesignArchitecture, s.designArchitecture},
        {DevStatusPlanEpicAndStory, s.planEpicsAndStories},
        {DevStatusDefineDataModel, s.defineDataModel},
        {DevStatusDefineAPI, s.defineAPIs},
        {DevStatusRunTest, s.runTests},
        {DevStatusDeploy, s.packageProject},
    }
    
    for _, stage := range stages {
        stage.executor(ctx, project, agentClient, ...)
    }
}
```

**3. WebSocket Service** (`backend/internal/services/websocket_service.go`)
```go
type WebSocketService interface {
    HandleConnection(ctx context.Context, userID string, conn *websocket.Conn)
    NotifyProjectStageUpdate(ctx context.Context, projectGuid string, stage *models.DevStage)
    NotifyProjectMessage(ctx context.Context, projectGuid string, message *models.ConversationMessage)
    NotifyProjectInfoUpdate(ctx context.Context, projectGuid string, project *models.Project)
}
```

### Asynq 异步任务

**任务创建** (`backend/internal/worker/project.go`)
```go
func CreateProjectDevelopmentTask(projectGuid string) (*asynq.Task, error) {
    payload := tasks.ProjectTaskPayload{
        ProjectGuid: projectGuid,
    }
    payloadBytes, _ := json.Marshal(payload)
    
    return asynq.NewTask(common.TaskTypeProjectDevelopment, payloadBytes), nil
}
```

**任务处理** (`backend/internal/worker/project.go`)
```go
func HandleProjectDevelopmentTask(ctx context.Context, task *asynq.Task) error {
    container := GetContainer() // 依赖注入容器
    return container.ProjectStageService.ProcessTask(ctx, task)
}
```

---

## 🤖 Agents 服务架构

### Handlers 层

**PM Handler** (`agents/internal/api/handlers/pm_handler.go`)
```go
type PmHandler struct {
    agentTaskService services.AgentTaskService
}

func (h *PmHandler) GetPRD(c *gin.Context) {
    var req agent.GetPRDReq
    c.ShouldBindJSON(&req)
    
    taskID, err := h.agentTaskService.Enqueue(
        req.ProjectGuid,
        common.AgentTypePM,
        "prd",
        req.ToBytes(),
    )
    
    c.JSON(200, utils.GetSuccessResponse("PRD任务已提交", taskID))
}
```

**Architect Handler** (`agents/internal/api/handlers/architect_handler.go`)
```go
type ArchitectHandler struct {
    agentTaskService services.AgentTaskService
}

func (h *ArchitectHandler) GetArchitecture(c *gin.Context) { /* ... */ }
func (h *ArchitectHandler) GetDatabase(c *gin.Context) { /* ... */ }
func (h *ArchitectHandler) GetAPIDefinition(c *gin.Context) { /* ... */ }
```

### Services 层

**Agent Task Service** (`agents/internal/services/agent_task_service.go`)
```go
type AgentTaskService interface {
    Enqueue(projectGuid, agentType, taskType string, payload []byte) (string, error)
    ProcessTask(ctx context.Context, task *asynq.Task) error
    GetTaskStatus(ctx context.Context, taskID string) (*tasks.TaskResult, error)
}

// 任务执行
func (s *agentTaskService) ProcessTask(ctx context.Context, task *asynq.Task) error {
    // 1. 解析任务
    var payload AgentTaskPayload
    json.Unmarshal(task.Payload(), &payload)
    
    // 2. 构建 Prompt 文件
    promptPath := s.buildPrompt(payload)
    
    // 3. 执行 BMad CLI
    result := s.commandService.SimpleExecute(
        ctx, workDir, "bmad", "run", "--prompt", promptPath
    )
    
    // 4. Git 提交
    s.gitService.CommitAndPush(ctx, payload.ProjectGuid, commitMessage)
    
    // 5. 更新任务结果
    return nil
}
```

**Command Service** (`agents/internal/services/command_service.go`)
```go
type CommandService interface {
    SimpleExecute(ctx context.Context, workDir, command string, args ...string) error
    StreamExecute(ctx context.Context, workDir, command string, args ...string) (<-chan string, error)
}
```

**Git Service** (`agents/internal/services/git_service.go`)
```go
type GitService interface {
    CommitAndPush(ctx context.Context, projectGuid, message string) error
    Clone(ctx context.Context, repoURL, targetPath string) error
    Pull(ctx context.Context, projectPath string) error
}
```

---

## 🚀 开发规范

### 1. Go 代码规范

- **包导入顺序**: 标准库 → 第三方库 → 项目内部包
- **错误处理**: 使用 `fmt.Errorf` 包装错误，提供上下文信息
- **日志记录**: 使用 `shared-models/logger` 统一日志接口
- **命名规范**: 
  - 包名: 小写，单数形式
  - 接口: 描述性名词 + 后缀 `er` (如 `ProjectService`)
  - 结构体: PascalCase
  - 函数: PascalCase (公开) / camelCase (私有)

**示例**:
```go
package services

import (
    "context"
    "fmt"
    
    "autocodeweb-backend/internal/models"
    "shared-models/common"
    "shared-models/logger"
)

type projectService struct {
    repo repositories.ProjectRepository
}

func (s *projectService) Create(ctx context.Context, req *models.CreateProjectRequest) (*models.Project, error) {
    if err := validateRequest(req); err != nil {
        return nil, fmt.Errorf("validate request: %w", err)
    }
    
    project, err := s.repo.Create(ctx, req)
    if err != nil {
        logger.Error("创建项目失败", 
            logger.String("name", req.Name),
            logger.String("error", err.Error()),
        )
        return nil, fmt.Errorf("create project: %w", err)
    }
    
    return project, nil
}
```

### 2. TypeScript/Vue 代码规范

- **组件命名**: PascalCase (如 `ProjectPanel.vue`)
- **Props 定义**: 使用 `defineProps<T>()` 指定类型
- **事件命名**: kebab-case (如 `@project-created`)
- **样式隔离**: 使用 `<style scoped>`
- **状态管理**: 复杂状态使用 Pinia Store

**示例**:
```typescript
// ProjectPanel.vue
<script setup lang="ts">
import { ref, computed } from 'vue'
import type { Project } from '@/types/project'

interface Props {
  project: Project
  readonly?: boolean
}

const props = withDefaults(defineProps<Props>(), {
  readonly: false
})

const emit = defineEmits<{
  'project-updated': [project: Project]
  'file-selected': [path: string]
}>()

const selectedFile = ref<string>('')

const handleFileClick = (path: string) => {
  selectedFile.value = path
  emit('file-selected', path)
}
</script>

<style scoped lang="scss">
.project-panel {
  display: flex;
  flex-direction: column;
  height: 100%;
  
  &__header {
    padding: var(--spacing-md);
    border-bottom: 1px solid var(--border-color);
  }
}
</style>
```

### 3. API 接口规范

**RESTful 设计原则**:
- `GET /api/v1/projects` - 获取项目列表
- `POST /api/v1/projects` - 创建项目
- `GET /api/v1/projects/{id}` - 获取项目详情
- `PUT /api/v1/projects/{id}` - 更新项目
- `DELETE /api/v1/projects/{id}` - 删除项目

**统一响应格式**:
```json
{
  "code": 0,
  "message": "success",
  "data": { /* ... */ },
  "timestamp": "2024-01-15T10:30:00Z"
}
```

### 4. 数据库操作规范

- **使用 Repository 模式**: 数据访问逻辑封装在 Repository 层
- **事务处理**: 涉及多表操作使用事务
- **软删除**: 重要数据使用软删除 (`deleted_at`)
- **索引优化**: 为常用查询字段添加索引

---

## 🔐 安全考虑

### 1. 认证与授权

- **JWT Token**: 无状态认证，Access Token + Refresh Token
- **Token 刷新**: Access Token 过期自动刷新
- **权限控制**: 基于角色的访问控制 (RBAC)

### 2. 数据安全

- **密码加密**: 使用 bcrypt 加密存储
- **SQL 注入防护**: 使用 GORM 参数化查询
- **XSS 防护**: 前端输入验证和转义

### 3. API 安全

- **CORS 配置**: 限制跨域请求来源
- **限流保护**: 使用 Redis 实现 API 限流
- **日志审计**: 记录关键操作日志

---

## 📝 重要提示

### 添加新功能时的注意事项

1. **新增 Agent 任务类型**:
   - 在 `shared-models/agent/requests.go` 添加请求结构体（包含 `CliTool` 字段）
   - 在 `shared-models/client/agent_client.go` 添加客户端方法
   - 在 `agents/internal/api/handlers` 添加对应 Handler（需根据 CLI 类型适配 Prompt）
   - 在 `backend/internal/services/project_stage_service.go` 添加阶段执行逻辑（传递 CLI 类型）

2. **新增开发阶段**:
   - 在 `shared-models/common/constants.go` 添加阶段常量
   - 更新 `GetDevStageDescription()` 和 `GetDevStageProgress()` 函数
   - 在 `project_stage_service.go` 的 stages 数组中添加阶段

3. **修改数据模型**:
   - 更新 `backend/internal/models` 中的模型定义
   - 更新数据库迁移脚本
   - 更新 `frontend/src/types` 中的 TypeScript 类型定义

4. **新增 WebSocket 消息类型**:
   - 在 `shared-models/common/constants.go` 添加消息类型常量
   - 在 `backend/internal/models/websocket.go` 添加消息结构体
   - 在前端 `websocket.ts` 中处理新消息类型

5. **新增或修改 CLI 工具支持**:
   - 在 `shared-models/common/constants.go` 添加 CLI 工具常量
   - 在 `agents/internal/services/agent_task_service.go` 添加命令构建逻辑
   - 在所有 Agent Handlers 中添加 Prompt 适配逻辑
   - 更新 `agents/internal/services/project_service.go` 的检测方法
   - 更新健康检查接口以支持新 CLI 的版本检测

---

## 🛠️ CLI 工具支持

### 支持的 CLI 类型

系统支持三种 AI CLI 工具，用于执行 Agent 任务：

| CLI 工具 | 命令名称 | 特点 | Prompt 格式 |
|---------|---------|------|------------|
| **Claude Code** | `claude` | 稳定，支持 JSON 输出，可恢复会话 | `@bmad/xxx.mdc` |
| **Qwen Code** | `qwen` | 国内可用，纯文本输出 | `@bmad/xxx.mdc` |
| **Gemini** | `gemini` | Google 登录，需特殊 Prompt | `@.bmad-core/agents/xxx.md` |

### CLI 类型检测机制

**位置**: `agents/internal/services/project_service.go`

```go
func (s *projectService) DetectCliTool(projectGuid string) string {
    projectPath := s.getProjectPath(projectGuid)
    
    // 根据目录检测 CLI 类型
    if utils.FileExists(filepath.Join(projectPath, ".claude")) {
        return common.CliToolClaudeCode
    }
    if utils.FileExists(filepath.Join(projectPath, ".qwen")) {
        return common.CliToolQwenCode
    }
    if utils.FileExists(filepath.Join(projectPath, ".gemini")) {
        return common.CliToolGemini
    }
    
    return common.CliToolClaudeCode // 默认
}
```

### CLI 类型处理优先级

1. **优先使用请求参数**: 如果 `req.BmadCliType` 或 `req.CliTool` 不为空，使用该值
2. **检测本地目录**: 如果请求参数为空，根据项目目录判断（`.claude`, `.qwen`, `.gemini`）
3. **验证并安装**: 如果 CLI 对应目录不存在，自动执行 `npx bmad-method install -f -i <cli-type> -d .`
4. **默认值**: 都不满足时使用 `claude-code`

### 命令执行适配

**位置**: `agents/internal/services/agent_task_service.go`

```go
// 根据 CLI 类型构建命令
switch cliTool {
case common.CliToolClaudeCode:
    cliCommand = "claude"
    useJsonOutput = true
    args = []string{"--dangerously-skip-permissions", "--output-format", "json", "-p", prompt}
    
case common.CliToolQwenCode:
    cliCommand = "qwen"
    useJsonOutput = false  // 纯文本输出
    args = []string{"-y", "-p", prompt}
    
case common.CliToolGemini:
    cliCommand = "gemini"
    useJsonOutput = false  // 纯文本输出
    args = []string{"-y", "-p", prompt}
}

result = h.commandService.SimpleExecute(ctx, projectGUID, cliCommand, args...)

// 根据输出格式处理结果
if useJsonOutput {
    // Claude: 解析 JSON 格式输出
    json.Unmarshal([]byte(result.Output), &claudeResponse)
} else {
    // Qwen/Gemini: 直接使用文本输出
    claudeResponse.Result = result.Output
}
```

### Prompt 适配策略

**位置**: `agents/internal/api/handlers/*_handler.go`

每个 Handler 根据 CLI 类型选择不同的 Prompt 格式：

```go
// 示例：PM Handler
func (s *PmHandler) GetPRD(c *gin.Context) {
    var req agent.GetPRDReq
    c.ShouldBindJSON(&req)
    
    // 根据 CLI 类型选择 Prompt
    var agentPrompt string
    if req.CliTool == common.CliToolGemini {
        agentPrompt = "@.bmad-core/agents/pm.md"  // Gemini 特殊格式
    } else {
        agentPrompt = "@bmad/pm.mdc"              // Claude/Qwen 通用格式
    }
    
    message := agentPrompt + " 我希望你根据 @docs/analyse 目录..."
    // ...
}
```

**Agent Prompt 映射表**:

| Agent | Claude/Qwen | Gemini |
|-------|------------|--------|
| Analyst | `@bmad/analyst.mdc` | `@.bmad-core/agents/analyst.md` |
| PM | `@bmad/pm.mdc` | `@.bmad-core/agents/pm.md` |
| UX Expert | `@bmad/ux-expert.mdc` | `@.bmad-core/agents/ux-expert.md` |
| Architect | `@bmad/architect.mdc` | `@.bmad-core/agents/architect.md` |
| PO | `@bmad/po.mdc` | `@.bmad-core/agents/po.md` |
| Dev | `@bmad/dev.mdc` | `@.bmad-core/agents/dev.md` |

### CLI 类型传递流程

```
Frontend (UserSettings)
  ↓ 选择 CLI 类型
Project.CliTool (存储在数据库)
  ↓ 
Backend (project_stage_service.go)
  ↓ getCliTool(project)
  ↓ 优先级: project.CliTool → user.DefaultCliTool → default
Agent Request (各种 *Req 结构体)
  ↓ CliTool 字段
Agents Service (handlers)
  ↓ 选择 Prompt 格式
AgentTaskService
  ↓ 构建执行命令
CommandService
  ↓ 执行对应 CLI
```

### 健康检查

**Agents 健康检查** (`agents/internal/api/handlers/health.go`):

```go
type AgentHealthResp struct {
    Status      string            `json:"status"`
    Version     string            `json:"version"`
    Environment map[string]string `json:"environment"`
}

// 检查 Node.js、npx 和三种 CLI 的版本
result.Environment["node"] = getVersion("node", "--version")
result.Environment["npx"] = getVersion("npx", "--version")
result.Environment["claude-code"] = getVersion("claude", "--version")
result.Environment["qwen-code"] = getVersion("qwen", "--version")
result.Environment["gemini"] = getVersion("gemini", "--version")
```

**Backend 健康检查** (`backend/internal/api/handlers/health.go`):

```go
type BackendHealthResp struct {
    Status       string                  `json:"status"`
    Version      string                  `json:"version"`
    AgentService *agent.AgentHealthResp  `json:"agent_service"`
}

// 调用 Agent 服务健康检查
agentClient := client.NewAgentClient(agentsURL, 5*time.Second)
if agentHealth, err := agentClient.HealthCheck(ctx); err == nil {
    resp.AgentService = agentHealth
} else {
    resp.AgentService = &agent.AgentHealthResp{Status: "unavailable"}
}
```

---

## 📚 参考文档

- **整体架构**: `docs/architect/Overall_Architecture.md`
- **后端架构**: `docs/architect/Backend_Architecture.md`
- **前端架构**: `docs/architect/Frontend_Architecture.md`
- **API 设计**: `docs/architect/API_Design.md`
- **数据模型**: `docs/architect/Data_Model_Design.md`
- **Agents 架构**: `agents/design/ARCHITECTURE.md`
- **Shared-Models**: `shared-models/README.md`

---

## 🎯 快速开发检查清单

### 修改现有功能
- [ ] 确认修改的文件位置和依赖关系
- [ ] 检查是否需要更新 shared-models
- [ ] 检查是否需要更新前后端类型定义
- [ ] 检查是否需要数据库迁移
- [ ] 更新相关测试用例
- [ ] 检查日志输出

### 添加新功能
- [ ] 设计功能流程和数据流
- [ ] 确定涉及的服务和组件
- [ ] 添加必要的常量和类型定义
- [ ] 实现后端服务和 API
- [ ] 实现前端组件和状态管理
- [ ] 添加错误处理和日志
- [ ] 测试功能完整性
- [ ] 更新文档

### 调试问题
- [ ] 检查日志输出 (backend/logs/app.log, agents/logs/app-maker-agents.log)
- [ ] 检查 WebSocket 连接状态
- [ ] 检查数据库记录
- [ ] 检查 Agent 任务状态
- [ ] 检查 Git 仓库提交记录

---

**文档版本**: v1.1
**最后更新**: 2024-10-14
**维护者**: AI探趣星船长

**更新日志**:
- v1.1 (2024-10-14): 新增 CLI 工具支持章节，包含 Claude Code、Qwen Code、Gemini 三种 CLI 的适配机制
- v1.0 (2024-01-15): 初始版本，包含整体架构和核心功能说明

> 💡 提示：本文档旨在帮助 AI 助手快速理解项目架构，确保在新会话中保持一致的开发方式。在实际开发中，请结合具体代码和需求进行调整。

